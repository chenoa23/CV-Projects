# -*- coding: utf-8 -*-
"""Week 6: Module 1 Lesson 4 Jupyter Notebook - Image Preprocessing Using OpenCV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BoQohEDYWig8RElU8aYmpTD4KNtnBXcB

# Image Preprocessing

This project explores a wide range of fundamental image preprocessing techniques using OpenCV in Python. It covers the step-by-step manipulation and enhancement of images for better computer vision performance or visual understanding. Key techniques demonstrated include:

- Reading, displaying, and saving images

- Image blurring (average, Gaussian, median)

- Grayscale conversion and brightness adjustment

- Edge detection using Canny algorithm

- Geometric transformations: scaling, cropping, rotation, translation, shearing

- Morphological operations: erosion, dilation, opening, closing, gradient, tophat, and blackhat

Each transformation is demonstrated with side-by-side visual outputs to illustrate their effect. This notebook serves as a hands-on introduction to image preprocessing â€” a vital first step in many computer vision pipelines.
"""

from google.colab import drive
drive.mount('/content/drive')

"""Here, in this jupyter nootbook, we are going to learn different image preprocessing techniques

Let us first install the required pacakges first
"""

pip install opencv-python

import cv2
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt

"""### Reading an image"""

img = cv2.imread(r"/content/drive/MyDrive/CAI 2840C/Week 6 + 7/cat-10-e1573844975155-scaled-2597241136.jpg", 1) #This is a image stored on my laptop
#you should try to use an image which is stored in your laptop
#the syntax is cv2.imread(r"< path >, flag(usually 1))

"""#### Check the shape of the image"""

print(img.shape)

"""### Printing the image"""

from google.colab.patches import cv2_imshow

cv2_imshow(img)
k = cv2.waitKey(0)
if k == 27 or k == ord('q'):
    cv2.destroyAllWindows()

"""After running the code, you will able to see another window open on your computer to display with the name city

#### Now, let us try to blur the image
"""

img1 = cv2.blur(img,(100,3)) #this is the blur function
cv2_imshow(img)
cv2_imshow(img1)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""You will able see two windows open up and you can compare the original image and blurred one

#### Converting the image into greyscale
"""

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

cv2.imwrite(r"/content/cat-10-e1573844975155-scaled-2597241136.jpg", gray)

"""### Pixel brightness transformations

#### Changing the brightness
"""

hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) #convert it to hsv
for x in range(0, len(hsv)):
    for y in range(0, len(hsv[0])):
        hsv[x, y][2] += 5
cv2_imshow(hsv)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""#### Let us now try Gaussian Blurring
In this method, instead of a box filter, a Gaussian kernel is used. It is done with the function, cv2.GaussianBlur(). We should specify the width and height of the kernel which should be positive and odd
"""

blur = cv2.GaussianBlur(img,(9,9),0)
cv2_imshow(img)
cv2_imshow(blur)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Were you able to find the difference?

#### Let us try out median Blur
the function cv2.medianBlur() takes the median of all the pixels under the kernel area and the central element is replaced with this median value
"""

median = cv2.medianBlur(img,5)
cv2_imshow(img)
cv2_imshow(median)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### We will now try Edge Detection
OpenCV puts all the above in single function, cv2.Canny(). We will see how to use it. First argument is our input image. Second and third arguments are our minVal and maxVal respectively. Fourth argument is aperture_size. It is the size of Sobel kernel used for find image gradients. By default it is 3. Last argument is L2gradient which specifies the equation for finding gradient magnitude.
"""

edges = cv2.Canny(img,100,200)
plt.subplot(121),plt.imshow(img,cmap = 'gray')
plt.title('Original Image'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(edges,cmap = 'gray')
plt.title('Edge Image'), plt.xticks([]), plt.yticks([])
plt.show()

"""Perfect right?!

### we will now try out some geometric transformations
##### Let's start off with Scaling

Scaling is just resizing of the image. OpenCV comes with a function cv.resize() for this purpose. The size of the image can be specified manually, or you can specify the scaling factor. Different interpolation methods are used.
"""

res = cv2.resize(img,None,fx=2, fy=2, interpolation = cv2.INTER_CUBIC)
cv2_imshow(img)
cv2_imshow(res)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""#### Image Slicing and Cropping"""

crop = img[50:180, 100:300]
cv2_imshow(img)
cv2_imshow(crop)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""#### Image Warping or Translation
Warping is the shifting of an object's location
"""

rows,cols,des = img.shape
M = np.float32([[1,0,100],[0,1,50]])
dst = cv2.warpAffine(img,M,(cols,rows)) #the object we want
cv2_imshow(dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Similary you can play around with the above to get the object you want

#### Let is try Image Rotation
penCV provides scaled rotation with adjustable center of rotation so that you can rotate at any location you prefer. To find this transformation matrix, OpenCV provides a function, cv.getRotationMatrix2D. Check out the below example which rotates the image by 90 degree with respect to center without any scaling.
"""

rows,cols,des = img.shape
# cols-1 and rows-1 are the coordinate limits.
M = cv2.getRotationMatrix2D(((cols-1)/2.0,(rows-1)/2.0),90,1) # the angle 90 can be changed to any angle you want
dst = cv2.warpAffine(img,M,(cols,rows))
cv2_imshow(dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Image Shearing
In Image Shearing, all parallel lines in the original image will still be parallel in the output image. To find the transformation matrix, we need three points from the input image and their corresponding locations in the output image. Then cv2.getAffineTransform will create a 2x3 matrix which is to be passed to cv2.warpAffine.
"""

pts1 = np.float32([[50,50],[200,50],[50,200]])
pts2 = np.float32([[10,100],[200,50],[100,250]])
M = cv2.getAffineTransform(pts1,pts2)
dst = cv2.warpAffine(img,M,(cols,rows))
plt.subplot(121),plt.imshow(img),plt.title('Input')
plt.subplot(122),plt.imshow(dst),plt.title('Output')
plt.show()

"""## Morphological Transformation

### Erosion
The basic idea of erosion is just like soil erosion only, it erodes away the boundaries of foreground object. All the pixels near boundary will be discarded depending upon the size of kernel. So the thickness or size of the foreground object decreases or simply white region decreases in the image. The function used is cv2.erode(img,kernel,NoOfIterations)
"""

kernel = np.ones((5,5),np.uint8)
erosion = cv2.erode(img,kernel,iterations = 1)
cv2_imshow(erosion)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Dilation
It is just opposite of erosion. Here, a pixel element is '1' if atleast one pixel under the kernel is '1'. So it increases the white region in the image or size of foreground object increases. The function used is cv2.dilate(img,kernel,NoOfIterations)
"""

dilation = cv2.dilate(img,kernel,iterations = 1)
cv2_imshow(dilation)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Opening
Opening is just another name of erosion followed by dilation. It is useful in removing noise, as we explained above. Here we use the function, cv.morphologyEx()
"""

opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
cv2_imshow(opening)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Closing
Closing is reverse of Opening, Dilation followed by Erosion. It is useful in closing small holes inside the foreground objects, or small black points on the object.
"""

closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)
cv2_imshow(closing)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Morphological Gradient
It is the difference between dilation and erosion of an image.
The result will look like the outline of the object.
"""

gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)
cv2_imshow(gradient)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Top Hat
It is the difference between input image and Opening of the image. Below example is done for a 9x9 kernel.
"""

tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)
cv2_imshow(tophat)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### Black Hat
It is the difference between the closing of the input image and input image.
"""

blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)
cv2_imshow(blackhat)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""Take a image and try to do this actions by yourselves"""

